{
    "bench_flagdata.AntintMode.time_antint_low_threshold_spw": {
        "code": "class AntintMode:\n    def time_antint_low_threshold_spw(self):\n        \"\"\"flagdata: mode antint, with low threshold; (original test_antint_spw3_low_threshold)\"\"\"\n        flagdata(vis=self.vis, mode='antint', spw='3', antint_ref_antenna='ea01', minchanfrac=-.1)\n\n    def setup(self):\n        self.setUp_data4tfcrop()",
        "min_run_count": 2,
        "name": "bench_flagdata.AntintMode.time_antint_low_threshold_spw",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "98a303508391da50600d29c7f8a74f95501abb178d78c35154642c8f7ec6f83c",
        "warmup_time": -1
    },
    "bench_flagdata.CalibrationBandpass.time_bandpass_clip_timerange": {
        "code": "class CalibrationBandpass:\n    def time_bandpass_clip_timerange(self):\n        \"\"\"Flagdata: clip a timerange from field 3C286_A; (original test_cal_time1)\"\"\"\n        flagdata(vis=self.vis, mode='clip', timerange='<14:12:52',clipzeros=True,\n                 clipminmax=[0.,0.35], datacolumn='CPARAM',flagbackup=False)\n\n    def setup(self):\n        self.setUp_bpass()",
        "min_run_count": 2,
        "name": "bench_flagdata.CalibrationBandpass.time_bandpass_clip_timerange",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "4595858d10a7650bb7d5b763b20cf03f4921f5bcd8feb0a09a3ce0a9c3cdca38",
        "warmup_time": -1
    },
    "bench_flagdata.CalibrationTsys.time_tsys_clip_fparam": {
        "code": "class CalibrationTsys:\n    def time_tsys_clip_fparam(self):\n        \"\"\"Flagdata: flag default data column FPARAM; (original test_default_fparam)\"\"\"\n        flagdata(vis=self.vis, mode='clip', clipminmax=[0,500], flagbackup=False,\n                 datacolumn='FPARAM')\n\n    def setup(self):\n        self.setUp_tsys()",
        "min_run_count": 2,
        "name": "bench_flagdata.CalibrationTsys.time_tsys_clip_fparam",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "7ee644928bb3e8de0bcf4711c3f266bb859ae288d2e7db42a0ea0a66d62550ad",
        "warmup_time": -1
    },
    "bench_flagdata.ClipMode.time_clip_corrected_data": {
        "code": "class ClipMode:\n    def time_clip_corrected_data(self):\n        \"\"\"flagdata: clip CORRECTED data column; (original test_datacol_corrected)\"\"\"\n        flagdata(vis=self.vis, flagbackup=False, mode='clip', datacolumn='CORRECTED',\n                 clipminmax=[0.,10.])\n\n    def setup(self):\n        self.setUp_data4tfcrop()",
        "min_run_count": 2,
        "name": "bench_flagdata.ClipMode.time_clip_corrected_data",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "07c4f1e0d3121fa540b2cd0e228a42009625c87cf37a05e16e62f3d95b57246b",
        "warmup_time": -1
    },
    "bench_flagdata.ClipMode.time_clip_with_timeavg": {
        "code": "class ClipMode:\n    def time_clip_with_timeavg(self):\n        \"\"\"flagdata: clip with time averaging in spw 9; (original test_timeavg_spw9_2scans)\"\"\"\n        flagdata(vis=self.vis, flagbackup=False, mode='clip', datacolumn='DATA', spw='9',\n                 timeavg=True, timebin='2s', clipminmax=[0.0, 0.08])\n\n    def setup(self):\n        self.setUp_data4tfcrop()",
        "min_run_count": 2,
        "name": "bench_flagdata.ClipMode.time_clip_with_timeavg",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "2be25377fea9922f68fb74d47702f7354f593a21a0c3ef79ea683f411e59cb03",
        "warmup_time": -1
    },
    "bench_flagdata.ElevationMode.time_elevation_interval": {
        "code": "class ElevationMode:\n    def time_elevation_interval(self):\n        \"\"\"Flagdata: flag an interval between upper and lower elevations; (original test_interval)\"\"\"\n        flagdata(vis = self.vis,mode = 'elevation',lowerlimit = 55,upperlimit = 60,\n                  savepars=False,flagbackup=False)\n\n    def setup(self):\n        self.setUp_ngc5921()",
        "min_run_count": 2,
        "name": "bench_flagdata.ElevationMode.time_elevation_interval",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "cbefafa13742c0d5fe0d9179be380f7801ee669bbc6fc2cbe3ba48c02dcf1b1c",
        "warmup_time": -1
    },
    "bench_flagdata.ListFileMode.time_list_from_3files": {
        "code": "class ListFileMode:\n    def time_list_from_3files(self):\n        \"\"\"Flagdata list mode reading commands from three files; (original test_file_CAS4819)\"\"\"\n        flagdata(vis=self.vis, mode='list', inpfile=[self.inpfile1, self.inpfile2, self.inpfile3],\n                 flagbackup=False)\n\n    def setup(self):\n        self.setUp_ngc5921()\n\n    def setup_cache(self):\n        # Create 3 flagcmd files and save to disk\n        myinput = \"scan='1'\\n\" \\\n                  \"scan='2'\\n\" \\\n                  \"# a comment line\\n\" \\\n                  \"scan='3'\"\n        create_input(myinput, self.inpfile1)\n    \n        myinput = \"scan='5'\\n\" \\\n                  \" \\n\" \\\n                  \"scan='6'\\n\" \\\n                  \"scan='7'\"\n        create_input(myinput, self.inpfile2)\n    \n        myinput = \"scan='4' mode='clip' clipminmax=[0,4]\"\n    \n        create_input(myinput, self.inpfile3)",
        "min_run_count": 2,
        "name": "bench_flagdata.ListFileMode.time_list_from_3files",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "bench_flagdata:214",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "dd8b2ea5edb3e265335cac2bf592eef280e5239f17d022f1fca37ab9738a0531",
        "warmup_time": -1
    },
    "bench_flagdata.ListMode.time_list_bandpassflag": {
        "code": "class ListMode:\n    def time_list_bandpassflag(self):\n        \"\"\"Flagdata list mode from pipeline hifa_bandpassflag\"\"\"\n        flagdata(\n            vis=self.vis,\n            mode=\"list\",\n            inpfile=[\n                \"intent='CALIBRATE_BANDPASS#ON_SOURCE' spw='16' antenna='CM05' \\\n                 timerange='20:09:50~20:09:52' field='J1924-2914' reason='bad antenna timestamp'\",\n                \"intent='CALIBRATE_BANDPASS#ON_SOURCE' spw='20' antenna='CM05' \\\n                          timerange='20:09:20~20:09:22' field='J1924-2914' reason='bad antenna timestamp'\",\n                \"intent='CALIBRATE_BANDPASS#ON_SOURCE' spw='20' antenna='CM05' \\\n                          timerange='20:10:21~20:10:22' field='J1924-2914' reason='bad antenna timestamp'\",\n                \"intent='CALIBRATE_BANDPASS#ON_SOURCE' spw='22' antenna='CM05' \\\n                          timerange='20:09:30~20:09:32' field='J1924-2914' reason='bad antenna timestamp'\",\n            ],\n            reason=\"any\",\n            action=\"apply\",\n            flagbackup=False,\n            savepars=False,\n        )\n\n    def setup(self):\n        self.setUp_WRay_perf()\n\n    def setup_cache(self):\n        if not os.path.exists(self.flags_cmd):\n            shutil.copyfile(\n                os.path.join(self.datapath, self.flags_cmd),\n                os.path.join(os.getcwd(), self.flags_cmd)\n            )",
        "min_run_count": 2,
        "name": "bench_flagdata.ListMode.time_list_bandpassflag",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "bench_flagdata:146",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "2971c3002f4dafe2840b191e5570935d4b7f7ff2873189a4c55df4ae808dc738",
        "warmup_time": -1
    },
    "bench_flagdata.ListMode.time_list_summary": {
        "code": "class ListMode:\n    def time_list_summary(self):\n        \"\"\"Flagdata list mode from pipeline hifa_rawflagchans\"\"\"\n        summary_dict = flagdata(\n            vis=self.vis,\n            mode=\"list\",\n            inpfile=[\"mode='summary' name='before'\"],\n            reason=\"any\",\n            action=\"apply\",\n            flagbackup=False,\n            savepars=False,\n        )\n\n    def setup(self):\n        self.setUp_WRay_perf()\n\n    def setup_cache(self):\n        if not os.path.exists(self.flags_cmd):\n            shutil.copyfile(\n                os.path.join(self.datapath, self.flags_cmd),\n                os.path.join(os.getcwd(), self.flags_cmd)\n            )",
        "min_run_count": 2,
        "name": "bench_flagdata.ListMode.time_list_summary",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "bench_flagdata:146",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "a3e3764d7dceb23f8ac0736e3a450613d2d10e11dc14ea682bbb0a78e1737111",
        "warmup_time": -1
    },
    "bench_flagdata.ListMode.time_list_tbuff": {
        "code": "class ListMode:\n    def time_list_tbuff(self):\n        \"\"\"Flagdata list mode from pipeline hifa_flagdata\"\"\"\n        flagdata(\n            vis=self.vis,\n            mode=\"list\",\n            inpfile=self.flags_cmd,\n            tbuff=[0.048, 0.0],\n            action=\"apply\",\n            flagbackup=False,\n            savepars=False,\n        )\n\n    def setup(self):\n        self.setUp_WRay_perf()\n\n    def setup_cache(self):\n        if not os.path.exists(self.flags_cmd):\n            shutil.copyfile(\n                os.path.join(self.datapath, self.flags_cmd),\n                os.path.join(os.getcwd(), self.flags_cmd)\n            )",
        "min_run_count": 2,
        "name": "bench_flagdata.ListMode.time_list_tbuff",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "bench_flagdata:146",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "53f2aaec8f44b81cb94f73fa21e5aac89218769ace8126661888f9c54374ff75",
        "warmup_time": -1
    },
    "bench_flagdata.RflagMode.time_rflag_numpy_types": {
        "code": "class RflagMode:\n    def time_rflag_numpy_types(self):\n        \"\"\"flagdata: rflag, thresholds using numpy types; (original test_rflag_partial_thresholds)\"\"\"\n        flagdata(vis=self.vis, mode='rflag', spw='9,10', timedev=[self.t1, self.t2], freqdev=0.5,\n                 flagbackup=False, extendflags=False)\n\n    def setup(self):\n        self.setUp_data4tfcrop()\n        self.t1 = [numpy.int32(1), 10, numpy.float32(0.1)]\n        self.t2 = [1, numpy.int16(11), numpy.float64(0.07)]",
        "min_run_count": 2,
        "name": "bench_flagdata.RflagMode.time_rflag_numpy_types",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "3f582e64491988dab48d1b83c4500bde3d09f14006d290ba96e3fa9ded4fa62b",
        "warmup_time": -1
    },
    "bench_flagdata.Selections.time_sel_abs_wvr": {
        "code": "class Selections:\n    def time_sel_abs_wvr(self):\n        \"\"\"flagdata: clip ABS_WVR; (original test_abs_wvr)\"\"\"\n        flagdata(vis=self.vis, mode='clip',clipminmax=[0,50], correlation='ABS_WVR', savepars=False,\n                 flagbackup=False)\n\n    def setup(self):\n        self.setUp_alma_ms()",
        "min_run_count": 2,
        "name": "bench_flagdata.Selections.time_sel_abs_wvr",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "ce5229049856ba918b3464ddc7f5aeee51402d91ce7a7d0cc3fb9d260d9fff87",
        "warmup_time": -1
    },
    "bench_flagdata.Selections.time_sel_autocorr_wvr": {
        "code": "class Selections:\n    def time_sel_autocorr_wvr(self):\n        \"\"\"flagdata: CAS-5286, do not flag auto-correlations in WVR data; (original test_autocorr_wvr)\"\"\"\n        flagdata(vis=self.vis, autocorr=True, flagbackup=False)\n\n    def setup(self):\n        self.setUp_alma_ms()",
        "min_run_count": 2,
        "name": "bench_flagdata.Selections.time_sel_autocorr_wvr",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "128022df8e55b6c9054c3ef806420b1f80f11fcb4ef8ce073e99894f83617c9c",
        "warmup_time": -1
    },
    "bench_flagdata.ShadowMode.time_shadow_absent_antennas": {
        "code": "class ShadowMode:\n    def time_shadow_absent_antennas(self):\n        \"\"\"flagdata: shadow by antennas not present in MS; (original test_CAS2399)\"\"\"\n        flagdata(vis=self.vis, mode='shadow', tolerance=0.0, addantenna=self.inpfile, flagbackup=False)\n\n    def setup(self):\n        self.setUp_shadowdata()\n    \n        # Create antennafile in disk\n        myinput = \"name=VLA01\\n\" \\\n                  \"diameter=25.0\\n\" \\\n                  \"position=[-1601144.96146691, -5041998.01971858, 3554864.76811967]\\n\" \\\n                  \"name=VLA02\\n\" \\\n                  \"diameter=25.0\\n\" \\\n                  \"position=[-1601105.7664601889, -5042022.3917835914, 3554847.245159178]\\n\" \\\n                  \"name=VLA09\\n\" \\\n                  \"diameter=25.0\\n\" \\\n                  \"position=[-1601197.2182404203, -5041974.3604805721, 3554875.1995636248]\\n\" \\\n                  \"name=VLA10\\n\" \\\n                  \"diameter=25.0\\n\" \\\n                  \"position=[-1601227.3367843349,-5041975.7011900628,3554859.1642644769]\\n\"\n    \n        create_input(myinput, self.antfile)\n    \n        # Create flagcmd file\n        myinput = \"mode='shadow' tolerance=0.0 addantenna='antfile.txt'\"\n        create_input(myinput, self.inpfile)",
        "min_run_count": 2,
        "name": "bench_flagdata.ShadowMode.time_shadow_absent_antennas",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "3b94aac813ae30b385cb446c642e9b3115a43bc492770d13667d2fd1bce00339",
        "warmup_time": -1
    },
    "bench_flagdata.ShadowMode.time_shadow_addantenna": {
        "code": "class ShadowMode:\n    def time_shadow_addantenna(self):\n        \"\"\"flagdata: use antenna file in list mode; (original test_addantenna)\"\"\"\n        flagdata(vis=self.vis, mode='list', inpfile=self.inpfile, savepars=True, outfile='withdict.txt',\n                 flagbackup=False)\n\n    def setup(self):\n        self.setUp_shadowdata()\n    \n        # Create antennafile in disk\n        myinput = \"name=VLA01\\n\" \\\n                  \"diameter=25.0\\n\" \\\n                  \"position=[-1601144.96146691, -5041998.01971858, 3554864.76811967]\\n\" \\\n                  \"name=VLA02\\n\" \\\n                  \"diameter=25.0\\n\" \\\n                  \"position=[-1601105.7664601889, -5042022.3917835914, 3554847.245159178]\\n\" \\\n                  \"name=VLA09\\n\" \\\n                  \"diameter=25.0\\n\" \\\n                  \"position=[-1601197.2182404203, -5041974.3604805721, 3554875.1995636248]\\n\" \\\n                  \"name=VLA10\\n\" \\\n                  \"diameter=25.0\\n\" \\\n                  \"position=[-1601227.3367843349,-5041975.7011900628,3554859.1642644769]\\n\"\n    \n        create_input(myinput, self.antfile)\n    \n        # Create flagcmd file\n        myinput = \"mode='shadow' tolerance=0.0 addantenna='antfile.txt'\"\n        create_input(myinput, self.inpfile)",
        "min_run_count": 2,
        "name": "bench_flagdata.ShadowMode.time_shadow_addantenna",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "21fb65a9cd413ce64af88b6c00ccfc1ee439a7d0413b88f9b383f4e30252b087",
        "warmup_time": -1
    },
    "bench_flagdata.TfcropMode.time_tfcrop_abs_rr": {
        "code": "class TfcropMode:\n    def time_tfcrop_abs_rr(self):\n        \"\"\"flagdata:: flag with tfcrop mode an ABS_RR correlation; (original test_tfcrop1)\"\"\"\n        flagdata(vis=self.vis, mode='tfcrop', correlation='ABS_RR',ntime=51.0,spw='9',\n                 savepars=False, extendflags=False)\n\n    def setup(self):\n        self.setUp_data4tfcrop()",
        "min_run_count": 2,
        "name": "bench_flagdata.TfcropMode.time_tfcrop_abs_rr",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "bc8ecea57bcf9178074a7728ad87a326ec8796d9a804a085da78d1247047edba",
        "warmup_time": -1
    },
    "bench_flagdata.TfcropMode.time_tfcrop_extendflags": {
        "code": "class TfcropMode:\n    def time_tfcrop_extendflags(self):\n        \"\"\"flagdata: flag with tfcrop mode and extend flags automatically\"\"\"\n        flagdata(vis=self.vis, mode='tfcrop', spw='0', extendflags=True, flagbackup=False)\n\n    def setup(self):\n        self.setUp_data4tfcrop()",
        "min_run_count": 2,
        "name": "bench_flagdata.TfcropMode.time_tfcrop_extendflags",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "686884535fe06d88a4737064c91e8fd3cc52616fc17d460c57cba3da7d04f97c",
        "warmup_time": -1
    },
    "bench_tclean_memory.tclean_memory_suite.peakmem_tclean_setweighting": {
        "code": "class tclean_memory_suite:\n    def peakmem_tclean_setweighting(self):\n        \"\"\"Adapted from CAS-13026\"\"\"\n        tclean(\n            vis=self.datapath,\n            imagename=self.imagename,\n            phasecenter=self.phasecenter,\n            scan=[\"17,11,13\"],\n            restoration=False,\n            datacolumn=\"data\",\n            pbcor=False,\n            spw=\"0\",\n            weighting=\"briggs\",\n            intent=\"OBSERVE_TARGET#ON_SOURCE\",\n            threshold=\"0mJy\",\n            robust=0.5,\n            savemodel=\"none\",\n            imsize=self.imsize,\n            stokes=\"I\",\n            nchan=self.nchan,\n            deconvolver=\"hogbom\",\n            field=\"Pillar_3\",\n            npixels=0,\n            niter=0,\n            pblimit=0.2,\n            restoringbeam=[],\n            cell=[\"0.94arcsec\"],\n            start=\"230.490186515GHz\",\n            outframe=\"LSRK\",\n            specmode=\"cube\",\n            width=\"0.0610478663509MHz\",\n            gridder=\"mosaic\",\n            interactive=False,\n            parallel=False,\n        )\n\n    def setup(self):\n        ## fresh copy of the test MS to the tmp directory where tests are run ?\n        # shutil.copytree(os.path.join(self.dataroot, self.input_ms),os.path.join(os.getcwd(), self.input_ms))\n        pass\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "name": "bench_tclean_memory.tclean_memory_suite.peakmem_tclean_setweighting",
        "param_names": [],
        "params": [],
        "setup_cache_key": "bench_tclean_memory:28",
        "timeout": 10000,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "c89589301c2c884b40375d00ec2f343d5ebdc195afbfc70ae2f149be692e8187"
    },
    "bench_tclean_memory.tclean_memory_suite.track_tclean_file_descriptors_cubemode_mosaic_briggs": {
        "code": "class tclean_memory_suite:\n    def track_tclean_file_descriptors_cubemode_mosaic_briggs(self):\n        \"\"\"Adapted from CAS-8755\n    \n        https://open-bitbucket.nrao.edu/projects/CASA/repos/casa6/browse/casatests/performance/test_perf_tclean_mem_setweighting.py?at=refs%2Fheads%2FCAS-13026#166-225\n    \n        Requires user configuration ~/.casa/rc to contain `synthesis.imager.memprofile.enable: 1`\n        Expected output is casa.synthesis.imager.memprofile.PID.HOSTNAME.DATE_TIME_when_test_started.txt\n        \"\"\"\n        # attribute for tracking metric\n        self.unit = \"file descriptors\"\n    \n        casalog.setlogfile(self.templogfile)\n        tclean(\n            vis=self.datapath,\n            imagename=self.imagename,\n            phasecenter=self.phasecenter,\n            scan=[\"17,11,13\"],\n            restoration=False,\n            datacolumn=\"data\",\n            pbcor=False,\n            spw=\"0\",\n            weighting=\"briggs\",\n            intent=\"OBSERVE_TARGET#ON_SOURCE\",\n            threshold=\"0mJy\",\n            robust=0.5,\n            savemodel=\"none\",\n            imsize=self.imsize,\n            stokes=\"I\",\n            nchan=self.nchan,\n            deconvolver=\"hogbom\",\n            field=\"Pillar_3\",\n            npixels=0,\n            niter=0,\n            pblimit=0.2,\n            restoringbeam=[],\n            cell=[\"0.94arcsec\"],\n            start=\"230.490186515GHz\",\n            outframe=\"LSRK\",\n            specmode=\"cube\",\n            width=\"0.0610478663509MHz\",\n            gridder=\"mosaic\",\n            interactive=False,\n            parallel=False,\n        )\n    \n        with open(self.templogfile) as mylog:\n            for line in mylog:\n                a_match = re.search(\"casa.synthesis.imager.memprofile\", line)\n                if a_match:\n                    str_match = a_match.string\n                    break\n    \n        # Get name of memprofile created by tclean\n        (start, middle, end) = str_match.partition(\"casa.synthesis.imager.memprofile\")\n        mem_profile = middle + end.rstrip()\n    \n        # Get the memory values of the second column named MemRSS_(VmRSS)_MB, for each row\n        with open(mem_profile, \"r\") as mfile:\n            memdict = OrderedDict()\n            maxFDSize = 0\n            for myrow in mfile:\n                linelist = []\n                print(myrow.rstrip())\n                if myrow.startswith(\"#\"):\n                    continue\n    \n                linelist = myrow.split(\",\")\n                tclean_step = str(linelist[-1].rstrip())\n                memdict[tclean_step.strip(\"[]\")] = int(linelist[1])\n                maxFDSize = max(maxFDSize, int(linelist[7]))\n    \n        return maxFDSize\n\n    def setup(self):\n        ## fresh copy of the test MS to the tmp directory where tests are run ?\n        # shutil.copytree(os.path.join(self.dataroot, self.input_ms),os.path.join(os.getcwd(), self.input_ms))\n        pass\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "name": "bench_tclean_memory.tclean_memory_suite.track_tclean_file_descriptors_cubemode_mosaic_briggs",
        "param_names": [],
        "params": [],
        "setup_cache_key": "bench_tclean_memory:28",
        "timeout": 10000,
        "type": "track",
        "unit": "unit",
        "version": "db6863cedbdc6e74efd8d2289e02d163d4d5d0711636a4003dd924edda273708"
    },
    "bench_tclean_time.TcleanCube.time_cube_standard_channel_gap": {
        "code": "class TcleanCube:\n    def time_cube_standard_channel_gap(self):\n        \"\"\"tclean\" mosaic cube with gap in channel selection - test_cube_21\"\"\"\n        ret = tclean(vis=self.msfile, field='0', imsize=100, cell='8.0arcsec', niter=10,\n                     specmode='cube', nchan=10, restfreq=['1.25GHz'],\n                     phasecenter=\"J2000 19:59:28.500 +40.44.01.50\", deconvolver='hogbom',\n                     spw='0:4~9;12~14', imagename=self.img + 'Cubetest_st4gap', start=4,\n                     width='', veltype='radio', outframe='LSRK', interpolation='nearest', parallel=False)\n\n    def setup(self):\n        self.prepData('refim_point.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanCube.time_cube_standard_channel_gap",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "955f38acfd52f97ee9d29fc749cb59a1cc43e4aba8a57c2cdf36b817208f65a1",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanCube.time_cube_standard_hogbom": {
        "code": "class TcleanCube:\n    def time_cube_standard_hogbom(self):\n        \"\"\"tclean: mosaic cube with Hogbom deconvolver -  test_cube_0\"\"\"\n        ret = tclean(vis=self.msfile, field='0', imsize=100, cell='8.0arcsec', niter=10,\n                     specmode='cube', nchan=10, restfreq=['1.25GHz'],\n                     phasecenter=\"J2000 19:59:28.500 +40.44.01.50\", deconvolver='hogbom',\n                     spw='0', imagename=self.img + 'Cubetest_chandefstdefwidth',\n                     start=0, width=1, veltype='radio', outframe='LSRK', interpolation='linear', parallel=False)\n\n    def setup(self):\n        self.prepData('refim_point.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanCube.time_cube_standard_hogbom",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "ead0eaac76215fd3ed59ddd926e9fdfb598dec50a29590840e6bf8a9c1139cfa",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanEphemeris.time_eph_multifield_mosaic_cubesource": {
        "code": "class TcleanEphemeris:\n    def time_eph_multifield_mosaic_cubesource(self):\n        \"\"\"tclean: multifield (mosaic gridder), cubesource mode - test_multifield_cube_eph\"\"\"\n        ret = tclean(vis=self.msfile, imagename=self.img, imsize=[480, 420], cell=['0.14arcsec'],\n                     phasecenter='TRACKFIELD', specmode='cubesource', gridder='mosaic', niter=0, interactive=0,\n                     parallel=False)\n\n    def setup(self):\n        self.prepData('venus_ephem_test.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanEphemeris.time_eph_multifield_mosaic_cubesource",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "00ce0c5528c88264188fee0e5eb249b01a7cca8850ec7ef630a12993c730c7c3",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanEphemeris.time_eph_multifield_mosaic_mfs": {
        "code": "class TcleanEphemeris:\n    def time_eph_multifield_mosaic_mfs(self):\n        \"\"\"tclean: multifield (mosaic gridder), mfs mode - test_multifield_mfs_eph\"\"\"\n        ret = tclean(vis=self.msfile, imagename=self.img, imsize=[480, 420], cell=['0.14arcsec'],\n                     phasecenter='TRACKFIELD', specmode='mfs', gridder='mosaic', niter=0, interactive=0,\n                     parallel=False)\n\n    def setup(self):\n        self.prepData('venus_ephem_test.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanEphemeris.time_eph_multifield_mosaic_mfs",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "6e2445dbdf62522bd52899868f2011931211ffe464d307ec91d9cb81128ca977",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanEphemeris.time_eph_singlefield_standard_cubesource": {
        "code": "class TcleanEphemeris:\n    def time_eph_singlefield_standard_cubesource(self):\n        \"\"\"tclean: single field (standard gridder), cubesource mode - test_onefield_cube_eph\"\"\"\n        ret = tclean(vis=self.msfile, field='0', imagename=self.img, imsize=[288, 288], cell=['0.14arcsec'],\n                   phasecenter='TRACKFIELD', specmode='cubesource', gridder='standard', niter=0,\n                   interactive=0, parallel=False)\n\n    def setup(self):\n        self.prepData('venus_ephem_test.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanEphemeris.time_eph_singlefield_standard_cubesource",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "a8296da992cffe858eb2811435c458febda5fae4910469d1c73fd270226aa6a2",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanEphemeris.time_eph_singlefield_standard_mfs": {
        "code": "class TcleanEphemeris:\n    def time_eph_singlefield_standard_mfs(self):\n        \"\"\"single field (standard gridder), mfs mode - test_onefield_mfs_eph\"\"\"\n        ret = tclean(vis=self.msfile, field='0', imagename=self.img, imsize=[288, 288], cell=['0.14arcsec'],\n                     phasecenter='TRACKFIELD', specmode='mfs', gridder='standard', niter=0, interactive=0,\n                     parallel=False)\n\n    def setup(self):\n        self.prepData('venus_ephem_test.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanEphemeris.time_eph_singlefield_standard_mfs",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "86598bce3ea0fb99cf8bda13c600b9e192d3136ac5ea54dac95a0703da26ff10",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanMoldelVis.time_mfs_automask_modelcolumn": {
        "code": "class TcleanMoldelVis:\n    def time_mfs_automask_modelcolumn(self):\n        \"\"\"tclean: mfs with automask and save model column, internally a separate predit model step - test_modelvis_12\"\"\"\n        ret = tclean(vis=self.msfile,imagename=self.img,imsize=100,cell='8.0arcsec',niter=10,\n                     savemodel='modelcolumn',usemask='auto-multithresh', parallel=False)\n\n    def setup(self):\n        self.prepData(\"refim_twochan.ms\")\n        delmod(self.msfile)\n        th.delmodels(self.msfile, modcol='delete')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanMoldelVis.time_mfs_automask_modelcolumn",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "7d60a63bc05d020e7f8100acf6044bbeda8cd4ef0f53267b53984b3580a421bc",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanMoldelVis.time_mfs_modelcolumn": {
        "code": "class TcleanMoldelVis:\n    def time_mfs_modelcolumn(self):\n        \"\"\"tclean: mfs mode saving a model column - test_modelvis_2\"\"\"\n        ret = tclean(vis=self.msfile, imagename=self.img, imsize=100, cell='8.0arcsec', niter=10,\n                     savemodel='modelcolumn',parallel=False)\n\n    def setup(self):\n        self.prepData(\"refim_twochan.ms\")\n        delmod(self.msfile)\n        th.delmodels(self.msfile, modcol='delete')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanMoldelVis.time_mfs_modelcolumn",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "39a0309c515e5dfe440b399768551ee76165e4551a994dcb41e2ed255523940e",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanMoldelVis.time_mfs_virtual_modelcolumn": {
        "code": "class TcleanMoldelVis:\n    def time_mfs_virtual_modelcolumn(self):\n        \"\"\"tclean: mfs saving a virtual model column - test_modelvis_3\"\"\"\n        ret = tclean(vis=self.msfile,imagename=self.img,imsize=100,cell='8.0arcsec',niter=10,\n                     savemodel='virtual',parallel=False)\n\n    def setup(self):\n        self.prepData(\"refim_twochan.ms\")\n        delmod(self.msfile)\n        th.delmodels(self.msfile, modcol='delete')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanMoldelVis.time_mfs_virtual_modelcolumn",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "322f52d2bb9054965cfef3b9c72cf5750386b28c13444d0055c32f9854934461",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanMultiField.time_multifield_cube_hogbom": {
        "code": "class TcleanMultiField:\n    def time_multifield_cube_hogbom(self):\n        \"\"\"tclean: Two fields, both cube - test_multifield_both_cube\"\"\"\n        th.write_file(self.img + '.out.txt',\n                           'imagename=' + self.img + '1\\nimsize=[80,80]\\ncell=[8.0arcsec,8.0arcsec]\\nphasecenter=J2000 19:58:40.895 +40.55.58.543\\nimagename=' + self.img + '2\\nimsize=[80,80]\\ncell=[8.0arcsec,8.0arcsec]\\nphasecenter=J2000 19:58:48.895 +40.55.58.543\\n')\n    \n        retpar = tclean(vis=self.msfile, imagename=self.img, imsize=100, cell='8.0arcsec',\n                        phasecenter=\"J2000 19:59:28.500 +40.44.01.50\", outlierfile=self.img + '.out.txt', niter=10,\n                        deconvolver='hogbom', interactive=0, specmode='cube', nchan=2, interpolation='nearest',\n                        parallel=False)\n\n    def setup(self):\n        self.prepData(\"refim_twopoints_twochan.ms\")",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanMultiField.time_multifield_cube_hogbom",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "2836dc90eddb8a98d0c365ea00b96a0a466f7b20afd5be17fbe8a81d4786c05e",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanMultiField.time_multifield_mfs_hogbom": {
        "code": "class TcleanMultiField:\n    def time_multifield_mfs_hogbom(self):\n        \"\"\"tclean : Two fields, both mfs - test_multifield_both_mfs\"\"\"\n        th.write_file(self.img + '.out.txt',\n                           'imagename=' + self.img + '1\\nnchan=1\\nimsize=[80,80]\\ncell=[8.0arcsec,8.0arcsec]\\nphasecenter=J2000 19:58:40.895 +40.55.58.543\\nusemask=user\\nmask=circle[[40pix,40pix],10pix]')\n    \n        ret = tclean(vis=self.msfile, imagename=self.img, imsize=100, cell='8.0arcsec',\n                     phasecenter=\"J2000 19:59:28.500 +40.44.01.50\", outlierfile=self.img + '.out.txt', niter=10,\n                     deconvolver='hogbom', interactive=0, parallel=False)\n\n    def setup(self):\n        self.prepData(\"refim_twopoints_twochan.ms\")",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanMultiField.time_multifield_mfs_hogbom",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "584885c4c0f7102c599166a8ab956de7f90dc8c4e6e3c78e933e767f1ada44ec",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanMultiField.time_multifield_mfs_mtmfs": {
        "code": "class TcleanMultiField:\n    def time_multifield_mfs_mtmfs(self):\n        \"\"\" tclean: Two fields, both mt-mfs - test_multifield_both_mtmfs\"\"\"\n        th.write_file(self.img + '.out.txt',\n                           'imagename=' + self.img + '1\\n\\nimsize=[80,80]\\ncell=[8.0arcsec,8.0arcsec]\\nphasecenter=J2000 19:58:40.895 +40.55.58.543\\nusemask=user\\nmask=circle[[40pix,40pix],10pix]')\n    \n        ret = tclean(vis=self.msfile, imagename=self.img, imsize=100, cell='8.0arcsec',\n                     phasecenter=\"J2000 19:59:28.500 +40.44.01.50\", outlierfile=self.img + '.out.txt', niter=10,\n                     deconvolver='mtmfs', interactive=0, parallel=False)\n\n    def setup(self):\n        self.prepData(\"refim_twopoints_twochan.ms\")",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanMultiField.time_multifield_mfs_mtmfs",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "59c89591914350f860f7a3751a9e2938ab06012ca76626cd7a184887900f21dc",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanSingleField.time_cube_standard_pcwdT": {
        "code": "class TcleanSingleField:\n    def time_cube_standard_pcwdT(self):\n        \"\"\"tclean: cube with perchanweightdensity True and briggs weighting - test_onefield_pcwdT_and_pcwdF\"\"\"\n        ret = tclean(self.msfile, imagename=self.img + '1', imsize=20, cell='8.0arcsec', niter=0, nchan=1,\n                     spw='0:1', interactive=0, gridder='standard', perchanweightdensity=True, specmode='cube',\n                     weighting='briggs', robust=0.5)\n\n    def setup(self):\n        self.prepData('refim_twochan.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanSingleField.time_cube_standard_pcwdT",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "87a4302d1c22d75c3f4d96f18d9c30e4c1474137142b236cb0e3d68a0980121b",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanSingleField.time_mfs_standard_clark": {
        "code": "class TcleanSingleField:\n    def time_mfs_standard_clark (self):\n        \"\"\"tclean: mfs with clark minor cycle - test_onefield_clark\"\"\"\n        ret = tclean(vis=self.msfile, imagename=self.img, imsize=100, cell='8.0arcsec', niter=10,\n                     deconvolver='clark', interactive=0, parallel=False)\n\n    def setup(self):\n        self.prepData('refim_twochan.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanSingleField.time_mfs_standard_clark",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "45e557b918e82e05c9ef0384a12bedee2352f06fa15568aa44ccdcfbc3ef7844",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanSingleField.time_mfs_standard_hogbom": {
        "code": "class TcleanSingleField:\n    def time_mfs_standard_hogbom(self):\n        \"\"\"tclean: mfs with hogbom minor cycle - test_onefield_hogbom\"\"\"\n        tricky_imagename = self.img + '_uid___A001_X1234a_X56cb.s19_0.J2253+1608_bp.more-dash.virtspw19.mfs.I.iter0.hoghbom'\n        ret = tclean(vis=self.msfile, imagename=tricky_imagename, imsize=100, cell='8.0arcsec', niter=10,\n                     deconvolver='hogbom', interactive=0,parallel=False)\n\n    def setup(self):\n        self.prepData('refim_twochan.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanSingleField.time_mfs_standard_hogbom",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "5821503c5f421a964ee0db6a6c4c210cdad6472f6ef7618578d526121f6a367b",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanSingleField.time_mfs_standard_hogbom_automask": {
        "code": "class TcleanSingleField:\n    def time_mfs_standard_hogbom_automask(self):\n        \"\"\"tclean: multi-threshold Autobox (minbeamfrac=0.3) - test_mask_autobox_multithresh_with_prune\"\"\"\n        ret = tclean(vis=self.msfile,imagename=self.img,imsize=1000,cell='8.0arcsec',niter=10,\n                     deconvolver='hogbom',interactive=0,usemask='auto-multithresh',\n                     minbeamfrac=0.3,parallel=False)\n\n    def setup(self):\n        self.prepData('refim_twochan.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanSingleField.time_mfs_standard_hogbom_automask",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "2365e23208a356d149685019af961a5affd74a878ffa9c936a79140e52fa676a",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanSingleField.time_mfs_standard_mtmfs": {
        "code": "class TcleanSingleField:\n    def time_mfs_standard_mtmfs(self):\n        \"\"\"tclean: mt-mfs with minor cycle iterations - test_onefield_mtmfs\"\"\"\n        ret = tclean(vis=self.msfile, imagename=self.img, imsize=100, cell='8.0arcsec', niter=10,\n                     deconvolver='mtmfs',interactive=0, parallel=False)\n\n    def setup(self):\n        self.prepData('refim_twochan.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanSingleField.time_mfs_standard_mtmfs",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "3ce1bb8c430057294c99dfe4aec9fd364467b132d20e56fd757a636ce5be02da",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanStokes.time_cube_stokes_IV": {
        "code": "class TcleanStokes:\n    def time_cube_stokes_IV(self):\n      \"\"\"tclean: cube with stokes V - test_stokes_cube_IV\"\"\"\n      ret = tclean(vis=self.msfile,imagename=self.img,imsize=100,cell='8.0arcsec',niter=10,\n                   stokes='IV',interactive=0,specmode='cube',interpolation='nearest',parallel=False)\n\n    def setup(self):\n        self.prepData('refim_point_linRL.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanStokes.time_cube_stokes_IV",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "0b57c9f7a080fab296d97a8612356c6bf64fa8d18998e6f4b4d31c4d0b6a0c8d",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanStokes.time_mfs_stokes_IV": {
        "code": "class TcleanStokes:\n    def time_mfs_stokes_IV(self):\n      \"\"\"tclean: mfs with stokes IV - test_stokes_mfs_IV\"\"\"\n      tclean(vis=self.msfile,imagename=self.img,imsize=100,cell='8.0arcsec',niter=10, stokes='IV',\n             parallel=False)\n\n    def setup(self):\n        self.prepData('refim_point_linRL.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanStokes.time_mfs_stokes_IV",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "d35d9a07fff354a74fbeb5aecec4abcc4dc94d0e83e10f366cb69e439004ed44",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanStokes.time_mtmfs_stokes_IQUV": {
        "code": "class TcleanStokes:\n    def time_mtmfs_stokes_IQUV(self):\n        \"\"\"tclean: mtmfs with stokes IQUV - test_stokes_mtmfs_IQUV\"\"\"\n        tclean(vis=self.msfile, imagename=self.img, imsize=100, cell='8.0arcsec', niter=10, stokes='IQUV',\n               deconvolver='mtmfs', nterms=2, parallel=False)\n\n    def setup(self):\n        self.prepData('refim_point_linRL.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanStokes.time_mtmfs_stokes_IQUV",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "7d3a14b77c55eebaebca13da5c79f9b48d38bf677f7e4aaf3c5103ca66e21006",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanWideFieldAWP.time_cube_awproject_hogbom": {
        "code": "class TcleanWideFieldAWP:\n    def time_cube_awproject_hogbom(self):\n        \"\"\"tclean: Cube with AW-Projection  and rotation off - test_widefield_aproj_cube\"\"\"\n        ret = tclean(vis=self.msfile, field='*', imagename=self.img, imsize=512, cell='10.0arcsec',\n                     phasecenter=\"J2000 19:59:28.500 +40.44.01.50\",specmode='cube', niter=1, gain=1.0,\n                     gridder='awproject', cfcache=self.img + '.cfcache',wbawp=True,conjbeams=False,\n                     psterm=False, computepastep=360.0, rotatepastep=360.0, deconvolver='hogbom',\n                     parallel=False)\n\n    def setup(self):\n        self.prepData(\"refim_mawproject.ms\")",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanWideFieldAWP.time_cube_awproject_hogbom",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "e5933d46b7d76f6e722504feff6442d7b22d7a07286b441227931d33b9adfae7",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanWideFieldAWP.time_mfs_awproject_hogbom": {
        "code": "class TcleanWideFieldAWP:\n    def time_mfs_awproject_hogbom(self):\n        \"\"\"tclean: MFS with narrowband AWProjection - test_widefield_aproj_mfs\"\"\"\n        ret = tclean(vis=self.msfile, spw='1', field='*', imagename=self.img, imsize=512, cell='10.0arcsec',\n                     phasecenter=\"J2000 19:59:28.500 +40.44.01.50\",niter=30, gridder='awproject', cfcache='',\n                     wbawp=False, conjbeams=True, psterm=False,computepastep=360.0,rotatepastep=360.0,\n                     deconvolver='hogbom', savemodel='modelcolumn', parallel=False)\n\n    def setup(self):\n        self.prepData(\"refim_mawproject.ms\")",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanWideFieldAWP.time_mfs_awproject_hogbom",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "b822057988cc0cc532d1b070ee27c6cca7c74940c97f32e4cae5442b0a580aec",
        "warmup_time": -1
    },
    "bench_tclean_time.TcleanWideFieldAWP.time_mfs_awproject_mtmfs": {
        "code": "class TcleanWideFieldAWP:\n    def time_mfs_awproject_mtmfs(self):\n        \"\"\"tclean: MFS with AWProjection and nt=2 stokes I - test_widefield_aproj_mtmfs  \"\"\"\n        ret = tclean(vis=self.msfile, spw='*', field='*', imagename=self.img, imsize=512, cell='10.0arcsec',\n                     phasecenter=\"J2000 19:59:28.500 +40.44.01.50\",niter=0, gridder='awproject',\n                     cfcache=self.img + '.cfcache', wbawp=True, conjbeams=False, psterm=False,\n                     computepastep=360.0,rotatepastep=360.0, deconvolver='mtmfs', parallel=False)\n\n    def setup(self):\n        self.prepData(\"refim_mawproject.ms\")",
        "min_run_count": 2,
        "name": "bench_tclean_time.TcleanWideFieldAWP.time_mfs_awproject_mtmfs",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "67a1d66f43c33d52452f3438452c599001c854eae7b69f546049457c746928d6",
        "warmup_time": -1
    },
    "bench_tclean_time.TestWideField.time_cube_mosaic_cbFalse_mwFalse_twofield": {
        "code": "class TestWideField:\n    def time_cube_mosaic_cbFalse_mwFalse_twofield(self):\n        \"\"\"tclean: - cube mosaic using conjbeams=False - test_cube_mosaic_cbFalse_mwFalse_twofield\"\"\"\n        tclean(vis=self.msfile, imagename=self.img,niter=10,specmode='cube',spw='*',imsize=1024, phasecenter='J2000 19h59m28.5 +40d40m01.5',cell='10.0arcsec',gridder='mosaic',field='0,1', conjbeams=False, wbawp=True, psterm=False,pblimit=0.1,reffreq='1.5GHz',pbcor=True,mosweight=False,parallel=False)\n\n    def setup(self):\n        self.prepData('refim_oneshiftpoint.mosaic.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TestWideField.time_cube_mosaic_cbFalse_mwFalse_twofield",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "63bcf68d13bddb55416a312bda1b664785d60b12dca3d7fffdae8b3b1d1a5fe6",
        "warmup_time": -1
    },
    "bench_tclean_time.TestWideField.time_cube_mosaic_cbFalse_mwFalse_twofield_upTrue": {
        "code": "class TestWideField:\n    def time_cube_mosaic_cbFalse_mwFalse_twofield_upTrue(self):\n        \"\"\"tclean: Cube mosaic with conjbeams=F, mosaicweight=F, usepointing=T, of two fields -  test_cube_mosaic_cbFalse_mwFalse_twofield_upTrue\"\"\"\n        tclean(vis=self.msfile, imagename=self.img,niter=10,specmode='cube',spw='*',imsize=1024, phasecenter='J2000 19h59m28.5 +40d40m01.5',cell='10.0arcsec',gridder='mosaic',field='0,1',  usepointing = True, conjbeams=False, wbawp=True, psterm=False,pblimit=0.1,reffreq='1.5GHz',pbcor=True,mosweight=False,parallel=False)\n\n    def setup(self):\n        self.prepData('refim_oneshiftpoint.mosaic.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TestWideField.time_cube_mosaic_cbFalse_mwFalse_twofield_upTrue",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "b19877202bcf5b8d17a9f8e6d2c73eab158bf9aa2ec22cdee6d2317fe09d2a1b",
        "warmup_time": -1
    },
    "bench_tclean_time.TestWideField.time_cube_mosaic_cbFalse_mwTrue_twofield": {
        "code": "class TestWideField:\n    def time_cube_mosaic_cbFalse_mwTrue_twofield(self):\n        \"\"\"tclean: - cube mosaic using conjbeams=False - test_cube_mosaic_cbFalse_mwTrue_twofield\"\"\"\n        tclean(vis=self.msfile, imagename=self.img,niter=10,specmode='cube',spw='*',imsize=1024, phasecenter='J2000 19h59m28.5 +40d40m01.5',cell='10.0arcsec',gridder='mosaic',field='0,1', conjbeams=False, wbawp=True, psterm=False,pblimit=0.1,reffreq='1.5GHz',pbcor=True,mosweight=True,parallel=False)\n\n    def setup(self):\n        self.prepData('refim_oneshiftpoint.mosaic.ms')",
        "min_run_count": 2,
        "name": "bench_tclean_time.TestWideField.time_cube_mosaic_cbFalse_mwTrue_twofield",
        "number": 2,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "07231c08248b92ddb7748a3d53cb53e2061c50e9ba90ad8d3f629ffefa382aed",
        "warmup_time": -1
    },
    "calibration.calibration_suite.time_applycal_callib": {
        "code": "class calibration_suite:\n    def time_applycal_callib(self):\n        \"\"\"Taken from the hifa_bandpassflag step of ALMA pipeline run 2019.1.01056.S_2021_07_20T07_45_18.149/\n    \n        Note that this is from on-the-fly application of preliminary phase-up, bandpass, and amplitude caltables, not the later stage hifa_applycal\n        Expected to take ~48s, could be sped up by splitting out SPWs (especially the square law detector windows) or applying to only one of them.\n        \"\"\"\n        applycal(\n            vis=self.input_ms,\n            field=\"J1924-2914\",\n            spw=\"16,18,20,22\",\n            intent=\"CALIBRATE_BANDPASS#ON_SOURCE\",\n            selectdata=True,\n            timerange=\"\",\n            uvrange=\"\",\n            antenna=\"*&*\",\n            scan=\"\",\n            observation=\"\",\n            msselect=\"\",\n            docallib=True,\n            callib=self.applycal_library,\n            gaintable=[],\n            gainfield=[],\n            interp=[],\n            spwmap=[],\n            calwt=[True],\n            parang=False,\n            applymode=\"calflagstrict\",\n            flagbackup=False,\n        )\n\n    def setup(self):\n        # run for each repeated test\n    \n        # iterations per sample\n        self.number = 2\n    \n        # fresh copy of the test MS to the tmp directory where tests are run\n        shutil.copytree(\n            os.path.join(self.dataroot, self.input_ms),\n            os.path.join(os.getcwd(), self.input_ms),\n        )\n    \n        # Copy the callibrary (and associated tables) into temporary test directory\n        shutil.copyfile(\n            os.path.join(self.dataroot, self.applycal_library),\n            os.path.join(os.getcwd(), self.applycal_library),\n        )\n    \n        for st in self.library_subtables:\n            if not os.path.exists(st):\n                shutil.copytree(\n                    os.path.join(self.dataroot, st), os.path.join(os.getcwd(), st)\n                )\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "min_run_count": 2,
        "name": "calibration.calibration_suite.time_applycal_callib",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "calibration:33",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "9ef394762fe7135f58c94c0e46a655fae93e7d107904ceff94d228f23b89a589",
        "warmup_time": -1
    },
    "calibration.calibration_suite.time_bandpass": {
        "code": "class calibration_suite:\n    def time_bandpass(self):\n        \"\"\"Taken from the hifa_bandpassflag step of ALMA pipeline run 2019.1.01056.S_2021_07_20T07_45_18.149/\"\"\"\n        bandpass(\n            vis=self.input_ms,\n            caltable=self.bandpass_table,\n            field=\"J1924-2914\",\n            spw=\"22\",\n            intent=\"CALIBRATE_BANDPASS#ON_SOURCE\",\n            selectdata=True,\n            antenna=\"0~9\",\n            solint=\"inf,15.625000MHz\",\n            combine=\"scan\",\n            refant=\"CM03,CM10,CM02,CM12,CM06,CM05,CM11,CM04,CM07,CM01\",\n            minblperant=4,\n            minsnr=3.0,\n            solnorm=True,\n            bandtype=\"B\",\n            append=True,\n            gaintable=[self.tsyscal_table, self.gaincal_table],\n            gainfield=[\"J1924-2914\", \"nearest\"],\n            interp=[\"linear,linear\", \"linear,linear\"],\n            spwmap=[\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16, 18, 20, 22, 16, 16, 18, 18, 20, 20, 22,],\n                [],\n            ],\n        )\n\n    def setup(self):\n        # run for each repeated test\n    \n        # iterations per sample\n        self.number = 2\n    \n        # fresh copy of the test MS to the tmp directory where tests are run\n        shutil.copytree(\n            os.path.join(self.dataroot, self.input_ms),\n            os.path.join(os.getcwd(), self.input_ms),\n        )\n    \n        # Copy the callibrary (and associated tables) into temporary test directory\n        shutil.copyfile(\n            os.path.join(self.dataroot, self.applycal_library),\n            os.path.join(os.getcwd(), self.applycal_library),\n        )\n    \n        for st in self.library_subtables:\n            if not os.path.exists(st):\n                shutil.copytree(\n                    os.path.join(self.dataroot, st), os.path.join(os.getcwd(), st)\n                )\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "min_run_count": 2,
        "name": "calibration.calibration_suite.time_bandpass",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "calibration:33",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "f706aa044f6bc64b915996b7bdd6bc5666cae0eb7c47ff9a70b5bced6c9fbd0c",
        "warmup_time": -1
    },
    "calibration.calibration_suite.time_gaincal": {
        "code": "class calibration_suite:\n    def time_gaincal(self):\n        \"\"\"Taken from the hifa_bandpassflag step of ALMA pipeline run 2019.1.01056.S_2021_07_20T07_45_18.149/\n    \n        Expected to take ~7s\n        \"\"\"\n        gaincal(\n            vis=self.input_ms,\n            caltable=self.gaincal_table,\n            field=\"J1924-2914\",\n            spw=\"16,18,20,22\",\n            intent=\"CALIBRATE_BANDPASS#ON_SOURCE\",\n            selectdata=True,\n            timerange=\"\",\n            uvrange=\"\",\n            antenna=\"0~9\",\n            scan=\"\",\n            observation=\"\",\n            msselect=\"\",\n            solint=\"int\",\n            combine=\"\",\n            preavg=-1.0,\n            refant=\"CM03,CM10,CM02,CM12,CM06,CM05,CM11,CM04,CM07,CM01\",\n            refantmode=\"flex\",\n            minblperant=4,\n            minsnr=3.0,\n            solnorm=False,\n            normtype=\"mean\",\n            gaintype=\"G\",\n            smodel=[],\n            calmode=\"p\",\n            solmode=\"\",\n            rmsthresh=[],\n            corrdepflags=False,\n            append=False,\n            splinetime=3600.0,\n            npointaver=3,\n            phasewrap=180.0,\n            docallib=False,\n            callib=\"\",\n            gaintable=[self.gaincal_table],\n            gainfield=[\"J1924-2914\"],\n            interp=[\"linear,linear\"],\n            spwmap=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16, 18, 20, 22, 16, 16, 18, 18, 20, 20, 22,],\n            parang=False,\n        )\n\n    def setup(self):\n        # run for each repeated test\n    \n        # iterations per sample\n        self.number = 2\n    \n        # fresh copy of the test MS to the tmp directory where tests are run\n        shutil.copytree(\n            os.path.join(self.dataroot, self.input_ms),\n            os.path.join(os.getcwd(), self.input_ms),\n        )\n    \n        # Copy the callibrary (and associated tables) into temporary test directory\n        shutil.copyfile(\n            os.path.join(self.dataroot, self.applycal_library),\n            os.path.join(os.getcwd(), self.applycal_library),\n        )\n    \n        for st in self.library_subtables:\n            if not os.path.exists(st):\n                shutil.copytree(\n                    os.path.join(self.dataroot, st), os.path.join(os.getcwd(), st)\n                )\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "min_run_count": 2,
        "name": "calibration.calibration_suite.time_gaincal",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "calibration:33",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "56f8a9022caccdafe4240fb9a2766b2d5d56cc1c784bd724822d3b040f5b5309",
        "warmup_time": -1
    },
    "casademo.calibration_suite.time_applycal_callib": {
        "code": "class calibration_suite:\n    def time_applycal_callib(self):\n        \"\"\"Taken from the hifa_bandpassflag step of ALMA pipeline run 2019.1.01056.S_2021_07_20T07_45_18.149/\n    \n        Note that this is from on-the-fly application of preliminary phase-up, bandpass, and amplitude caltables, not the later stage hifa_applycal\n        Expected to take ~48s, could be sped up by splitting out SPWs (especially the square law detector windows) or applying to only one of them.\n        \"\"\"\n        applycal(\n            vis=self.input_ms,\n            field=\"J1924-2914\",\n            spw=\"16,18,20,22\",\n            intent=\"CALIBRATE_BANDPASS#ON_SOURCE\",\n            selectdata=True,\n            timerange=\"\",\n            uvrange=\"\",\n            antenna=\"*&*\",\n            scan=\"\",\n            observation=\"\",\n            msselect=\"\",\n            docallib=True,\n            callib=self.applycal_library,\n            gaintable=[],\n            gainfield=[],\n            interp=[],\n            spwmap=[],\n            calwt=[True],\n            parang=False,\n            applymode=\"calflagstrict\",\n            flagbackup=False,\n        )\n\n    def setup(self):\n        # run for each repeated test\n    \n        # iterations per sample\n        self.number = 2\n    \n        # fresh copy of the test MS to the tmp directory where tests are run\n        shutil.copytree(\n            os.path.join(self.dataroot, self.input_ms),\n            os.path.join(os.getcwd(), self.input_ms),\n        )\n    \n        # Copy the callibrary (and associated tables) into temporary test directory\n        shutil.copyfile(\n            os.path.join(self.dataroot, self.applycal_library),\n            os.path.join(os.getcwd(), self.applycal_library),\n        )\n    \n        for st in self.library_subtables:\n            if not os.path.exists(st):\n                shutil.copytree(\n                    os.path.join(self.dataroot, st), os.path.join(os.getcwd(), st)\n                )\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "min_run_count": 2,
        "name": "casademo.calibration_suite.time_applycal_callib",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "casademo:287",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "9ef394762fe7135f58c94c0e46a655fae93e7d107904ceff94d228f23b89a589",
        "warmup_time": -1
    },
    "casademo.calibration_suite.time_bandpass": {
        "code": "class calibration_suite:\n    def time_bandpass(self):\n        \"\"\"Taken from the hifa_bandpassflag step of ALMA pipeline run 2019.1.01056.S_2021_07_20T07_45_18.149/\"\"\"\n        bandpass(\n            vis=self.input_ms,\n            caltable=self.bandpass_table,\n            field=\"J1924-2914\",\n            spw=\"22\",\n            intent=\"CALIBRATE_BANDPASS#ON_SOURCE\",\n            selectdata=True,\n            antenna=\"0~9\",\n            solint=\"inf,15.625000MHz\",\n            combine=\"scan\",\n            refant=\"CM03,CM10,CM02,CM12,CM06,CM05,CM11,CM04,CM07,CM01\",\n            minblperant=4,\n            minsnr=3.0,\n            solnorm=True,\n            bandtype=\"B\",\n            append=True,\n            gaintable=[self.tsyscal_table, self.gaincal_table],\n            gainfield=[\"J1924-2914\", \"nearest\"],\n            interp=[\"linear,linear\", \"linear,linear\"],\n            spwmap=[\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16, 18, 20, 22, 16, 16, 18, 18, 20, 20, 22,],\n                [],\n            ],\n        )\n\n    def setup(self):\n        # run for each repeated test\n    \n        # iterations per sample\n        self.number = 2\n    \n        # fresh copy of the test MS to the tmp directory where tests are run\n        shutil.copytree(\n            os.path.join(self.dataroot, self.input_ms),\n            os.path.join(os.getcwd(), self.input_ms),\n        )\n    \n        # Copy the callibrary (and associated tables) into temporary test directory\n        shutil.copyfile(\n            os.path.join(self.dataroot, self.applycal_library),\n            os.path.join(os.getcwd(), self.applycal_library),\n        )\n    \n        for st in self.library_subtables:\n            if not os.path.exists(st):\n                shutil.copytree(\n                    os.path.join(self.dataroot, st), os.path.join(os.getcwd(), st)\n                )\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "min_run_count": 2,
        "name": "casademo.calibration_suite.time_bandpass",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "casademo:287",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "f706aa044f6bc64b915996b7bdd6bc5666cae0eb7c47ff9a70b5bced6c9fbd0c",
        "warmup_time": -1
    },
    "casademo.calibration_suite.time_gaincal": {
        "code": "class calibration_suite:\n    def time_gaincal(self):\n        \"\"\"Taken from the hifa_bandpassflag step of ALMA pipeline run 2019.1.01056.S_2021_07_20T07_45_18.149/\n    \n        Expected to take ~7s\n        \"\"\"\n        gaincal(\n            vis=self.input_ms,\n            caltable=self.gaincal_table,\n            field=\"J1924-2914\",\n            spw=\"16,18,20,22\",\n            intent=\"CALIBRATE_BANDPASS#ON_SOURCE\",\n            selectdata=True,\n            timerange=\"\",\n            uvrange=\"\",\n            antenna=\"0~9\",\n            scan=\"\",\n            observation=\"\",\n            msselect=\"\",\n            solint=\"int\",\n            combine=\"\",\n            preavg=-1.0,\n            refant=\"CM03,CM10,CM02,CM12,CM06,CM05,CM11,CM04,CM07,CM01\",\n            refantmode=\"flex\",\n            minblperant=4,\n            minsnr=3.0,\n            solnorm=False,\n            normtype=\"mean\",\n            gaintype=\"G\",\n            smodel=[],\n            calmode=\"p\",\n            solmode=\"\",\n            rmsthresh=[],\n            corrdepflags=False,\n            append=False,\n            splinetime=3600.0,\n            npointaver=3,\n            phasewrap=180.0,\n            docallib=False,\n            callib=\"\",\n            gaintable=[self.gaincal_table],\n            gainfield=[\"J1924-2914\"],\n            interp=[\"linear,linear\"],\n            spwmap=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16, 18, 20, 22, 16, 16, 18, 18, 20, 20, 22,],\n            parang=False,\n        )\n\n    def setup(self):\n        # run for each repeated test\n    \n        # iterations per sample\n        self.number = 2\n    \n        # fresh copy of the test MS to the tmp directory where tests are run\n        shutil.copytree(\n            os.path.join(self.dataroot, self.input_ms),\n            os.path.join(os.getcwd(), self.input_ms),\n        )\n    \n        # Copy the callibrary (and associated tables) into temporary test directory\n        shutil.copyfile(\n            os.path.join(self.dataroot, self.applycal_library),\n            os.path.join(os.getcwd(), self.applycal_library),\n        )\n    \n        for st in self.library_subtables:\n            if not os.path.exists(st):\n                shutil.copytree(\n                    os.path.join(self.dataroot, st), os.path.join(os.getcwd(), st)\n                )\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "min_run_count": 2,
        "name": "casademo.calibration_suite.time_gaincal",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "casademo:287",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "56f8a9022caccdafe4240fb9a2766b2d5d56cc1c784bd724822d3b040f5b5309",
        "warmup_time": -1
    },
    "casademo.flagdata_suite.time_flagdata_bandpassflag": {
        "code": "class flagdata_suite:\n    def time_flagdata_bandpassflag(self):\n        \"\"\"hifa_bandpassflag\"\"\"\n        flagdata(\n            vis=self.datapath,\n            mode=\"list\",\n            inpfile=[\n                \"intent='CALIBRATE_BANDPASS#ON_SOURCE' spw='16' antenna='CM05' \\\n                 timerange='20:09:50~20:09:52' field='J1924-2914' reason='bad antenna timestamp'\",\n                \"intent='CALIBRATE_BANDPASS#ON_SOURCE' spw='20' antenna='CM05' \\\n                          timerange='20:09:20~20:09:22' field='J1924-2914' reason='bad antenna timestamp'\",\n                \"intent='CALIBRATE_BANDPASS#ON_SOURCE' spw='20' antenna='CM05' \\\n                          timerange='20:10:21~20:10:22' field='J1924-2914' reason='bad antenna timestamp'\",\n                \"intent='CALIBRATE_BANDPASS#ON_SOURCE' spw='22' antenna='CM05' \\\n                          timerange='20:09:30~20:09:32' field='J1924-2914' reason='bad antenna timestamp'\",\n            ],\n            reason=\"any\",\n            action=\"apply\",\n            flagbackup=False,\n            savepars=False,\n        )\n\n    def setup(self):\n        # run for each repeated test\n    \n        # iterations per sample\n        self.number = 2\n    \n        # assign our test dataset\n        self.datapath = os.path.join(self.dataroot, self.input_ms)\n    \n        ## fresh copy of the test MS to the tmp directory where tests are run ?\n        # if not os.path.exists(self.input_ms):\n        #    shutil.copytree(os.path.join(self.dataroot, self.input_ms),\n        #                    os.path.join(os.getcwd(), self.input_ms))\n    \n        # Copy the flagcmd text file into temporary test directory\n        if not os.path.exists(self.flags_cmd):\n            shutil.copyfile(\n                os.path.join(self.dataroot, self.flags_cmd),\n                os.path.join(os.getcwd(), self.flags_cmd),\n            )\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "min_run_count": 2,
        "name": "casademo.flagdata_suite.time_flagdata_bandpassflag",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "casademo:182",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "f55e0ffa6be9d655555c5081a0e7bf2bc00b253273ba7c220de0bd2cfb3baf6c",
        "warmup_time": -1
    },
    "casademo.flagdata_suite.time_flagdata_list": {
        "code": "class flagdata_suite:\n    def time_flagdata_list(self):\n        \"\"\"hifa_flagdata\"\"\"\n        flagdata(\n            vis=self.datapath,\n            mode=\"list\",\n            inpfile=self.flags_cmd,\n            tbuff=[0.048, 0.0],\n            action=\"apply\",\n            flagbackup=False,\n            savepars=False,\n        )\n\n    def setup(self):\n        # run for each repeated test\n    \n        # iterations per sample\n        self.number = 2\n    \n        # assign our test dataset\n        self.datapath = os.path.join(self.dataroot, self.input_ms)\n    \n        ## fresh copy of the test MS to the tmp directory where tests are run ?\n        # if not os.path.exists(self.input_ms):\n        #    shutil.copytree(os.path.join(self.dataroot, self.input_ms),\n        #                    os.path.join(os.getcwd(), self.input_ms))\n    \n        # Copy the flagcmd text file into temporary test directory\n        if not os.path.exists(self.flags_cmd):\n            shutil.copyfile(\n                os.path.join(self.dataroot, self.flags_cmd),\n                os.path.join(os.getcwd(), self.flags_cmd),\n            )\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "min_run_count": 2,
        "name": "casademo.flagdata_suite.time_flagdata_list",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "casademo:182",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "1a40b66ffb4a43d48af3407bae817ed4f7667fe778880859384f5f2e7c9c5d1f",
        "warmup_time": -1
    },
    "casademo.flagdata_suite.time_flagdata_list_summary": {
        "code": "class flagdata_suite:\n    def time_flagdata_list_summary(self):\n        \"\"\"hifa_rawflagchans\"\"\"\n        summary_dict = flagdata(\n            vis=self.datapath,\n            mode=\"list\",\n            inpfile=[\"mode='summary' name='before'\"],\n            reason=\"any\",\n            action=\"apply\",\n            flagbackup=False,\n            savepars=False,\n        )\n\n    def setup(self):\n        # run for each repeated test\n    \n        # iterations per sample\n        self.number = 2\n    \n        # assign our test dataset\n        self.datapath = os.path.join(self.dataroot, self.input_ms)\n    \n        ## fresh copy of the test MS to the tmp directory where tests are run ?\n        # if not os.path.exists(self.input_ms):\n        #    shutil.copytree(os.path.join(self.dataroot, self.input_ms),\n        #                    os.path.join(os.getcwd(), self.input_ms))\n    \n        # Copy the flagcmd text file into temporary test directory\n        if not os.path.exists(self.flags_cmd):\n            shutil.copyfile(\n                os.path.join(self.dataroot, self.flags_cmd),\n                os.path.join(os.getcwd(), self.flags_cmd),\n            )\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "min_run_count": 2,
        "name": "casademo.flagdata_suite.time_flagdata_list_summary",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "casademo:182",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "3eb284062687484026a1defb4fceb705e83b244e37405f8794d431940ff44b08",
        "warmup_time": -1
    },
    "casademo.flagdata_suite.time_flagdata_summary": {
        "code": "class flagdata_suite:\n    def time_flagdata_summary(self):\n        \"\"\"hifa_importdata\"\"\"\n        summary_dict = flagdata(vis=self.datapath, flagbackup=False, mode=\"summary\")\n\n    def setup(self):\n        # run for each repeated test\n    \n        # iterations per sample\n        self.number = 2\n    \n        # assign our test dataset\n        self.datapath = os.path.join(self.dataroot, self.input_ms)\n    \n        ## fresh copy of the test MS to the tmp directory where tests are run ?\n        # if not os.path.exists(self.input_ms):\n        #    shutil.copytree(os.path.join(self.dataroot, self.input_ms),\n        #                    os.path.join(os.getcwd(), self.input_ms))\n    \n        # Copy the flagcmd text file into temporary test directory\n        if not os.path.exists(self.flags_cmd):\n            shutil.copyfile(\n                os.path.join(self.dataroot, self.flags_cmd),\n                os.path.join(os.getcwd(), self.flags_cmd),\n            )\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "min_run_count": 2,
        "name": "casademo.flagdata_suite.time_flagdata_summary",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "casademo:182",
        "timeout": 10000,
        "type": "time",
        "unit": "seconds",
        "version": "9e569fb4e2a2f68e59c510bbf889632173be867104a4e5ba5a98d0eb110e82fb",
        "warmup_time": -1
    },
    "casademo.tclean_memory_suite.peakmem_tclean_setweighting": {
        "code": "class tclean_memory_suite:\n    def peakmem_tclean_setweighting(self):\n        \"\"\"Adapted from CAS-13026\"\"\"\n        tclean(\n            vis=self.datapath,\n            imagename=self.imagename,\n            phasecenter=self.phasecenter,\n            scan=[\"17,11,13\"],\n            restoration=False,\n            datacolumn=\"data\",\n            pbcor=False,\n            spw=\"0\",\n            weighting=\"briggs\",\n            intent=\"OBSERVE_TARGET#ON_SOURCE\",\n            threshold=\"0mJy\",\n            robust=0.5,\n            savemodel=\"none\",\n            imsize=self.imsize,\n            stokes=\"I\",\n            nchan=self.nchan,\n            deconvolver=\"hogbom\",\n            field=\"Pillar_3\",\n            npixels=0,\n            niter=0,\n            pblimit=0.2,\n            restoringbeam=[],\n            cell=[\"0.94arcsec\"],\n            start=\"230.490186515GHz\",\n            outframe=\"LSRK\",\n            specmode=\"cube\",\n            width=\"0.0610478663509MHz\",\n            gridder=\"mosaic\",\n            interactive=False,\n            parallel=False,\n        )\n\n    def setup(self):\n        ## fresh copy of the test MS to the tmp directory where tests are run ?\n        # shutil.copytree(os.path.join(self.dataroot, self.input_ms),os.path.join(os.getcwd(), self.input_ms))\n        pass\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "name": "casademo.tclean_memory_suite.peakmem_tclean_setweighting",
        "param_names": [],
        "params": [],
        "setup_cache_key": "casademo:37",
        "timeout": 10000,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "c89589301c2c884b40375d00ec2f343d5ebdc195afbfc70ae2f149be692e8187"
    },
    "casademo.tclean_memory_suite.track_tclean_file_descriptors_cubemode_mosaic_briggs": {
        "code": "class tclean_memory_suite:\n    def track_tclean_file_descriptors_cubemode_mosaic_briggs(self):\n        \"\"\"Adapted from CAS-8755\n    \n        https://open-bitbucket.nrao.edu/projects/CASA/repos/casa6/browse/casatests/performance/test_perf_tclean_mem_setweighting.py?at=refs%2Fheads%2FCAS-13026#166-225\n    \n        Requires user configuration ~/.casa/rc to contain `synthesis.imager.memprofile.enable: 1`\n        Expected output is casa.synthesis.imager.memprofile.PID.HOSTNAME.DATE_TIME_when_test_started.txt\n        \"\"\"\n        # attribute for tracking metric\n        unit = \"file descriptors\"\n    \n        casalog.setlogfile(self.templogfile)\n        tclean(\n            vis=self.datapath,\n            imagename=self.imagename,\n            phasecenter=self.phasecenter,\n            scan=[\"17,11,13\"],\n            restoration=False,\n            datacolumn=\"data\",\n            pbcor=False,\n            spw=\"0\",\n            weighting=\"briggs\",\n            intent=\"OBSERVE_TARGET#ON_SOURCE\",\n            threshold=\"0mJy\",\n            robust=0.5,\n            savemodel=\"none\",\n            imsize=self.imsize,\n            stokes=\"I\",\n            nchan=self.nchan,\n            deconvolver=\"hogbom\",\n            field=\"Pillar_3\",\n            npixels=0,\n            niter=0,\n            pblimit=0.2,\n            restoringbeam=[],\n            cell=[\"0.94arcsec\"],\n            start=\"230.490186515GHz\",\n            outframe=\"LSRK\",\n            specmode=\"cube\",\n            width=\"0.0610478663509MHz\",\n            gridder=\"mosaic\",\n            interactive=False,\n            parallel=False,\n        )\n    \n        with open(self.templogfile) as mylog:\n            for line in mylog:\n                a_match = re.search(\"casa.synthesis.imager.memprofile\", line)\n                if a_match:\n                    str_match = a_match.string\n                    break\n    \n        # Get name of memprofile created by tclean\n        (start, middle, end) = str_match.partition(\"casa.synthesis.imager.memprofile\")\n        mem_profile = middle + end.rstrip()\n    \n        # Get the memory values of the second column named MemRSS_(VmRSS)_MB, for each row\n        with open(mem_profile, \"r\") as mfile:\n            memdict = OrderedDict()\n            maxFDSize = 0\n            for myrow in mfile:\n                linelist = []\n                print(myrow.rstrip())\n                if myrow.startswith(\"#\"):\n                    continue\n    \n                linelist = myrow.split(\",\")\n                tclean_step = str(linelist[-1].rstrip())\n                memdict[tclean_step.strip(\"[]\")] = int(linelist[1])\n                maxFDSize = max(maxFDSize, int(linelist[7]))\n    \n        return maxFDSize\n\n    def setup(self):\n        ## fresh copy of the test MS to the tmp directory where tests are run ?\n        # shutil.copytree(os.path.join(self.dataroot, self.input_ms),os.path.join(os.getcwd(), self.input_ms))\n        pass\n\n    def setup_cache(self):\n        # only run once for repeated tests\n        pass",
        "name": "casademo.tclean_memory_suite.track_tclean_file_descriptors_cubemode_mosaic_briggs",
        "param_names": [],
        "params": [],
        "setup_cache_key": "casademo:37",
        "timeout": 10000,
        "type": "track",
        "unit": "unit",
        "version": "e3aeb6edf33f78d2db6d58dfc61576924a9768f7a205164fcd839666bde1ae63"
    },
    "version": 2
}